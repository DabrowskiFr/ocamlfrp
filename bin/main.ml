open Format
open Fmt 
open Ocamlfrp.Util
open Ocamlfrp.Coiterator

(* let _ = show pp_print_int (to_list nat 10) *)
(* let _ = show pp_print_int (to_list (pre 0 nat) 10)
let _ = show pp_print_int (to_list (plus nat nat) 10)
let _ = show pp_print_int (to_list (even nat) 10) *)
(* let _ = show pp_print_int (to_list (map ((+) 1) nat) 10) *)
(* let _ = show (pair pp_print_int pp_print_int) (to_list (fork nat) 10) *)

type ('a,'b,'c) sf = ('a, 'c) co -> ('b, 'c) co

let ints : (int, int) co = Co ((fun (n:int) -> (n, n + 1)), 0) 

let floats : (float, float) co = Co ((fun (f:float) -> (f, f +. 1.)), 0.)

(* we can't zip two streams as they are not first class values *)
(* we need the first operator to work on a part of the stream value *)

let ints_and_floats : (float * int, int) co =
  Co ((fun s -> ((float_of_int s, s), s + 1)), 0)

let inverse : (float * int, int * int, 'c) sf =
  first (arr int_of_float)

let sum = inverse >>> (arr ( fun (x,y) -> x + y))

let squares = 
  (arr (fun n -> (n,n)) >>> (arr (fun (n,m) -> n * m))) ints

(* composition pour l'addition *)

(* let _ = show (pair pp_print_int pp_print_int) (to_list (inverse ints_and_floats) 10)

let _ = show (pp_print_int) (to_list (sum ints_and_floats) 10)

let _ = show (pair pp_print_int pp_print_int) (to_list (first (map ((+) 1)) (fork ints)) 10) *)

let counter_inner : (unit * int, 'a) co -> (int * int, 'a) co = 
  arr (fun ((), n) -> (n,n+1))

let extints : (unit, int * 'a) co = Co ((fun ((n,s) : int * 'a) -> ((), (n + 1, s))), (0,())) 

let counter = loop counter_inner extints

let _ = show (pp_print_int) (to_list counter 10)

(* We compare different kind of streams and functions over streams *)
(* The most general case are mathematical functions *)
(* Then we study *)
(* - Streams as implemented by the Seq Ocaml module *)
(* - Coiterators as studied by Caspi and Pouzet *)
(* - Stream functions as proposed by Yampa, the general case *)
(* - Stream functions generated by arrow constructors *)


(* synchronous functions, are function that do not need to know the transition function 
    of their input, but only their value at the current step *)
(* type sf a b *)
(* study this objects in their generality, not restricting to the use of arrow constructors *)

(* use list of unit as clock *)
(* let plus (Co (f,s) : (int,'a) cstream) (Co (f',s') : (int, 'b) cstream) = 1 *)

(* type ('a,'s) cstream = Co of ('s -> ('a * 's)) * 's  *)

(* examples *)


(* concrete streams functions *)

(* pre requires the state of its parameter to evaluate it plus the value to insert *)


(* for testing purpose *)
(* let rec to_list (Co (f,s) : ('a,'s) cstream) (n : int) : 'a list =
  if n > 0 then 
      let (a, s') = f s in 
        a::(to_list (Co (f, s')) (n-1))
  else []

let show (pp : formatter -> 'a -> unit) (c : ('a,'b) cstream) (n :int ): unit =
  Format.fprintf std_formatter "%a\n" (pp_print_list ?pp_sep:(Some pp_print_space) pp) (to_list c n) *)


        (* En yampa, la récursion est dans la définition des arrows *)

      (* even : can't be encode in Yampa as we cannot have different clocks *)
      
      (* combine identity and None *)
      (* identity in category, fmap pour option, return  *)
      (* faire le lien avec choose de Yampa*)

      (* les horloges ne sont pas arbitraires, on considère des sous horloges
        d'une horloge principale *)
        (* les sous horloges peuvent être combinées, on doit retrouver à la 
        fin un programme sur l'horloge globale*)

      (* can we have the clock in the type or as an argument *)
      (* + generalization to boxes *)

      (* yampa signals are not first class citizen, thus boxes which are 
        generalization of boxes cannot be use as first class citizens *)

              (* quel opérateur peut permettre de faire le pre sans loop, 
        fby natif ? *)

      (* Codage des when,.... *)
      (* notion d'horloge en Yampa ? *)

            (* faire fby comme une boite qui decalle son signal d'entrée *)
      (* ~pre *)
      (* deux flux d'entrée, d'abord le premier puis le second *)

      (* d'abord première projectin puis second *)
      (* ici on construit dynamiquement des boites, sous le arrow  *)
