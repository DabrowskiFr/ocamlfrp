(* arrows *) 
(* acts as the identity on the state *)

(* important : all operators produces boxes whose output state has the same kind as the input state*)
(* As expected, only the loop function changes the structure of the state 
  by adding the new 'memory to it' *)
(* operators open box to rearrange the plugins *)



(*  A PROUVER : les fonctions Yampa génére des sf qui ne modifient pas l'état !!! *)
(* leur implantation *)
(* The state is always the one of the global input *)

(* let first (f : ('a, 's1) co -> ('b, 's2) co) : ('a * 'c, 's1) co -> ('b * 'c, 's1 * 's2) co = 
  fun (Co (h, s))  ->  
    let (Co (h', s')) = f (Co ((fun s1 -> let (x,y) = h s1 in (fst x, y)), s)) in
      Co ((fun ((s1, s2)) -> 
        let (x, y) = h' s2 and (z,t) = h s1 in 
          ((x, snd z), (t,y))), (s,s'))   *)
        
(* composition *)

(* let compose (g : ('b,'s3) co -> ('c,'s4) co) (f : ('a, 's1) co -> ('b, 's2) co) : 
  ('a, ('s1 * 's3)) co -> ('c, ('s2 * 's4)) co =
        fun (Co (t, (s1,s3))) ->
          let (x, (y,z)) = t (s1,s3) in
          let (Co (h, i) : ('b, 's2) co) = f (Co ((fun s1 -> let (x,(y, _)) = t  (s1, s3) in (x,y)), s1)) in 
          let (Co (h', i') : ('c, 's3) co) = g (Co ((fun s3 -> let (x,(_,y)) = t (s1, s3) in (x,y)), s3)) in *)
          (* Co (f, ) *)
(* loop *)

(* possibilité de combiner une fois qu'on est sur les streams 
  mais pas sur les costreams ??? *)
(* let fst (f : ('a,'s1) co -> ('b, 's2) co) : ('a*'c,'s1) co -> ('a*'c,'s2) co = 
  fun (Co (g,s)) ->
    Co (fun s -> ) *)
  (* Co ((fun (a,s) -> ((a,?),s)), s) *)

(** For testing purpose*)

  

  (* let rec apply_to_list (f : ('a,'b) t -> ('a,'c) t) (l : 'a list ) : 'a list =
  match l with 
    | [] -> []
    | a::t -> let (b,s') = f s in b::(apply_to_list (Co (f, s')) t) *)


    (* devrait seulement fournir l'entrée, utilser loop après *)
(* let std_input  = 
    loop (
    arr ( 
      fun ((), s) -> 
        let s' = match input_char stdin with None -> s | Some c -> s^(String.make 1 c) in
      (s',s'))) ""

let _ = show (pp_print_string) (Some "inputs :") (to_list (std_input dummy) 4) *)

(* We compare different kind of streams and functions over streams *)
(* The most general case are mathematical functions *)
(* Then we study *)
(* - Streams as implemented by the Seq Ocaml module *)
(* - Coiterators as studied by Caspi and Pouzet *)
(* - Stream functions as proposed by Yampa, the general case *)
(* - Stream functions generated by arrow constructors *)


(* synchronous functions, are function that do not need to know the transition function 
    of their input, but only their value at the current step *)
(* type sf a b *)
(* study this objects in their generality, not restricting to the use of arrow constructors *)

(* use list of unit as clock *)
(* let plus (Co (f,s) : (int,'a) cstream) (Co (f',s') : (int, 'b) cstream) = 1 *)

(* type ('a,'s) cstream = Co of ('s -> ('a * 's)) * 's  *)

(* examples *)


(* concrete streams functions *)

(* pre requires the state of its parameter to evaluate it plus the value to insert *)


(* for testing purpose *)
(* let rec to_list (Co (f,s) : ('a,'s) cstream) (n : int) : 'a list =
  if n > 0 then 
      let (a, s') = f s in 
        a::(to_list (Co (f, s')) (n-1))
  else []

let show (pp : formatter -> 'a -> unit) (c : ('a,'b) cstream) (n :int ): unit =
  Format.fprintf std_formatter "%a\n" (pp_print_list ?pp_sep:(Some pp_print_space) pp) (to_list c n) *)


        (* En yampa, la récursion est dans la définition des arrows *)

      (* even : can't be encode in Yampa as we cannot have different clocks *)
      
      (* combine identity and None *)
      (* identity in category, fmap pour option, return  *)
      (* faire le lien avec choose de Yampa*)

      (* les horloges ne sont pas arbitraires, on considère des sous horloges
        d'une horloge principale *)
        (* les sous horloges peuvent être combinées, on doit retrouver à la 
        fin un programme sur l'horloge globale*)

      (* can we have the clock in the type or as an argument *)
      (* + generalization to boxes *)

      (* yampa signals are not first class citizen, thus boxes which are 
        generalization of boxes cannot be use as first class citizens *)

              (* quel opérateur peut permettre de faire le pre sans loop, 
        fby natif ? *)

      (* Codage des when,.... *)
      (* notion d'horloge en Yampa ? *)

            (* faire fby comme une boite qui decalle son signal d'entrée *)
      (* ~pre *)
      (* deux flux d'entrée, d'abord le premier puis le second *)

      (* d'abord première projectin puis second *)
      (* ici on construit dynamiquement des boites, sous le arrow  *)

        (* deux versions pour les entrées sorties, co pour un branchement en amont et 
  sf pour un branchement local (type références )*)

(* les entrées sorties posent problème , elles bloquent l'évaluation du coiterateur *)
(* un coiterateur ne peut pas recevoir de valeur, elle doit être placée à l'intérieur  *)
(* cela suggère qu'il est mieux d'avoir un flux d'entrée ???? *)
(* let co_output_char : *)


(* open In_channel *)

(* let co_input_char : (char option, unit) co = 
  Co ((fun () -> (input_char stdin), ()), ())

let sig_input_char : (unit,'a) co -> (char option, 'b) co = 
  arr (fun () -> input_char stdin)

let sig_output_string : (string, 'a) co -> (unit, 'a) co =
  arr (Format.fprintf std_formatter "%s\n") *)
