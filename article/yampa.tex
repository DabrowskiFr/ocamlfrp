AFRP is based on John Hughes's Arrow framework, where signals are treated as second-class values and can only be accessed through signal functions.
Given two types \(a\) and \(b\), the type of signal functions \(\YSF{a}{b}\)
is defined as $\YSF{a}{b} = a \rightarrow b \times \YSF{a}{b}$.
A signal function of this ty    pe consumes the head of a stream of type \(a\),
produces a value of type \(b\), and returns a new signal to handle the remainder of 
the stream. The combinators listed below can be used to construct signal functions in AFRP.
\begin{equation*}
    \begin{array}{lcl}
        \YArrow & : & (a \rightarrow b) \rightarrow \YSF{a}{b}\\
        \YArrow\ f & = & \lambda a. (f\ a, \YArrow\ f)\\\\
        \YFirst & : & \YSF{a}{b} \rightarrow \YSF{(a \times )}{(b\times c)}\\
        \YFirst\ F & = & \lambda (a,c). \letin{(b,F')}{F a}{((a,c), F')}\\\\ 
        (\YCompose) &:& \YSF{a}{b} \rightarrow \YSF{b}{c} \rightarrow \YSF{a}{c}\\
        F \YCompose G & = & \lambda a. \letin{(b,F')}{F\ a}{\letin{(c,G')}{G\ b}{(c, F' \YCompose G' )}}\\\\
        \YLoop & : & \YSF{(a \times c)}{(b \times c)} \rightarrow c \rightarrow \YSF{a}{b}\\
        \YLoop\ F\ v & = &  \lambda a. \letin{((b,v'), F')}{F\ (a,v)}{\YLoop\ F'\ v'}
    \end{array}
\end{equation*}
Note that, by construction, the new stream function differs from the original only in the parameters of the 
\(\YLoop\) combinators. 
The function \({\tt{run}}\), shown below, converts a stream function 
\(\YSF{a}{b}\) into a function that operates on streams.
\begin{equation}
    \begin{array}{lcl}
        {\tt{run}} & : & \YSF{a}{b} \rightarrow \stream\ a \rightarrow \stream\ b\\
        {\tt{run}}\ F\ (a \cdot s) & = & \letin{(b,F')}{F\ a}{b \cdot {\tt{run}}\ F'\ s}
    \end{array}
\end{equation}


